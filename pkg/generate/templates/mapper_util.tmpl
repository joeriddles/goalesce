// Code generated by github.com/joeriddles/gorm-oapi-codegen DO NOT EDIT.
package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"regexp"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type _Mapper interface {
	Map(from, to interface{}) error
}

type _modelMapper struct{}

func _NewModelMapper() _Mapper {
	return &_modelMapper{}
}

// Add properties from the request body to the model instance.
func (m *_modelMapper) Map(
	body interface{},
	model interface{},
) error {
	update := map[string]interface{}{}
	err := convertBodyToUpdate(body, &update)
	if err != nil {
		return err
	}

	for key, value := range update {
		pascalKey := toPascalCase(key)
		if err := m.setField(model, pascalKey, value); err != nil {
			return err
		}
	}

	return nil
}

type _updateMapper struct{}

func _NewUpdateMapper() _Mapper {
	return &_updateMapper{}
}

// Map an API request object to a GORM update with the correct column names.
func (m *_updateMapper) Map(
	body interface{},
	to interface{},
) error {
	update, ok := to.(*map[string]interface{})
	if !ok {
		return errors.New("must pass a map")
	}

	if err := convertBodyToUpdate(body, update); err != nil {
		return err
	}

	for key, value := range *update {
		snakeCaseKey := toSnakeCase(key)
		delete(*update, key)
		(*update)[snakeCaseKey] = value
	}

	return nil
}

// Convert the request body to an update map.
func convertBodyToUpdate(
	value interface{},
	update *map[string]interface{},
) error {
	bodyBytes, err := json.Marshal(value)
	if err != nil {
		return err
	}

	if err = json.Unmarshal(bodyBytes, &update); err != nil {
		return err
	}

	return nil
}

// setField sets the provided obj field with provided value.
//
// The `obj` parameter must be a pointer to a struct, otherwise it soundly
// fails.
// The provided `value` type should match with the struct field being set.
//
// See https://github.com/oleiade/reflections/blob/master/reflections.go
func (m *_modelMapper) setField(obj interface{}, name string, value interface{}) error {
	// Fetch the field reflect.Value
	structValue := reflect.ValueOf(obj).Elem()
	structFieldValue := structValue.FieldByName(name)

	if !structFieldValue.IsValid() {
		return fmt.Errorf("no such field: %s in obj", name)
	}

	if !structFieldValue.CanSet() {
		return fmt.Errorf("cannot set %s field value", name)
	}

	structFieldType := structFieldValue.Type()
	val := reflect.ValueOf(value)
	if structFieldType != val.Type() {
		invalidTypeError := fmt.Errorf(
			"provided value type didn't match obj field type",
		)
		return invalidTypeError
	}

	structFieldValue.Set(val)
	return nil
}

var camelCaseRegex = regexp.MustCompile("([a-z0-9])([A-Z])")

// Convert the string to camelCase.
func toCamelCase(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return ""
	}

	s = camelCaseRegex.ReplaceAllString(s, "${1} ${2}")

	words := strings.Fields(s)
	if len(words) == 0 {
		return ""
	}

	for i := 1; i < len(words); i++ {
		caser := cases.Title(language.AmericanEnglish)
		words[i] = caser.String(strings.ToLower(words[i]))
	}

	words[0] = strings.ToLower(words[0])
	return strings.Join(words, "")

}

// Convert the string to snake_case.
func toSnakeCase(s string) string {
	camelCase := toCamelCase(s)
	snake := camelCaseRegex.ReplaceAllString(camelCase, "${1}_${2}")
	return strings.ToLower(snake)
}

// Convert the string to PascalCase.
func toPascalCase(s string) string {
	if len(s) == 0 {
		return s
	}
	camelCase := toCamelCase(s)
	return strings.ToUpper(camelCase[0:1]) + camelCase[1:]
}
